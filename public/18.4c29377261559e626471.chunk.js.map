{"version":3,"sources":["webpack:///./src/helpers/bytes.ts","webpack:///./src/lib/polyfill.ts"],"names":["bytesToHex","bytes","length","arr","Array","i","toString","join","bytesFromHex","hexString","len","Uint8Array","Math","ceil","start","parseInt","charAt","substr","bytesToBase64","mod3","result","nLen","nUint24","nIdx","String","fromCharCode","uint6ToBase64","replace","nUint6","bytesCmp","bytes1","bytes2","bufferConcats","args","reduce","acc","v","byteLength","tmp","lastLength","forEach","b","set","ArrayBuffer","Object","defineProperty","prototype","get","this","str","enumerable","configurable","randomize","crypto","Error","getRandomValues","concat","toJSON","findAndSplice","verify","index","findIndex","splice","undefined","toHHMMSS","leadZero","sec_num","hours","floor","minutes","seconds","Promise","finally","fn","onFinally","callback","resolve","then","reason","reject","safeFinally","catch"],"mappings":"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","file":"18.4c29377261559e626471.chunk.js","sourcesContent":["/*\r\n * https://github.com/morethanwords/tweb\r\n * Copyright (C) 2019-2021 Eduard Kuzmenko\r\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\r\n * \r\n * Originally from:\r\n * https://github.com/zhukov/webogram\r\n * Copyright (C) 2014 Igor Zhukov <igor.beatle@gmail.com>\r\n * https://github.com/zhukov/webogram/blob/master/LICENSE\r\n */\r\n\r\nexport function bytesToHex(bytes: ArrayLike<number>) {\r\n  const length = bytes.length;\r\n  const arr: string[] = new Array(length);\r\n  for(let i = 0; i < length; ++i) {\r\n    arr[i] = (bytes[i] < 16 ? '0' : '') + (bytes[i] || 0).toString(16);\r\n  }\r\n  return arr.join('');\r\n}\r\n\r\nexport function bytesFromHex(hexString: string) {\r\n  const len = hexString.length;\r\n  const bytes = new Uint8Array(Math.ceil(len / 2));\r\n  let start = 0;\r\n\r\n  if(len % 2) { // read 0x581 as 0x0581\r\n    bytes[start++] = parseInt(hexString.charAt(0), 16);\r\n  }\r\n\r\n  for(let i = start; i < len; i += 2) {\r\n    bytes[start++] = parseInt(hexString.substr(i, 2), 16);\r\n  }\r\n\r\n  return bytes;\r\n}\r\n\r\nexport function bytesToBase64(bytes: number[] | Uint8Array) {\r\n  let mod3: number;\r\n  let result = '';\r\n\r\n  for(let nLen = bytes.length, nUint24 = 0, nIdx = 0; nIdx < nLen; ++nIdx) {\r\n    mod3 = nIdx % 3;\r\n    nUint24 |= bytes[nIdx] << (16 >>> mod3 & 24);\r\n    if(mod3 === 2 || nLen - nIdx === 1) {\r\n      result += String.fromCharCode(\r\n        uint6ToBase64(nUint24 >>> 18 & 63),\r\n        uint6ToBase64(nUint24 >>> 12 & 63),\r\n        uint6ToBase64(nUint24 >>> 6 & 63),\r\n        uint6ToBase64(nUint24 & 63)\r\n      );\r\n      nUint24 = 0;\r\n    }\r\n  }\r\n\r\n  return result.replace(/A(?=A$|$)/g, '=');\r\n}\r\n\r\nexport function uint6ToBase64(nUint6: number) {\r\n  return nUint6 < 26\r\n    ? nUint6 + 65\r\n    : nUint6 < 52\r\n      ? nUint6 + 71\r\n      : nUint6 < 62\r\n        ? nUint6 - 4\r\n        : nUint6 === 62\r\n          ? 43\r\n          : nUint6 === 63\r\n            ? 47\r\n            : 65;\r\n}\r\n\r\nexport function bytesCmp(bytes1: number[] | Uint8Array, bytes2: number[] | Uint8Array) {\r\n  const len = bytes1.length;\r\n  if(len !== bytes2.length) {\r\n    return false;\r\n  }\r\n\r\n  for(let i = 0; i < len; ++i) {\r\n    if(bytes1[i] !== bytes2[i]) {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  return true;\r\n}\r\n\r\nexport function bytesXor(bytes1: Uint8Array, bytes2: Uint8Array) {\r\n  const len = bytes1.length;\r\n  const bytes = new Uint8Array(len);\r\n\r\n  for(let i = 0; i < len; ++i) {\r\n    bytes[i] = bytes1[i] ^ bytes2[i];\r\n  }\r\n\r\n  return bytes;\r\n}\r\n\r\n/* export function bytesToArrayBuffer(b: number[]) {\r\n  return (new Uint8Array(b)).buffer;\r\n}\r\n\r\nexport function convertToArrayBuffer(bytes: any | ArrayBuffer | Uint8Array) {\r\n  // Be careful with converting subarrays!!\r\n  if(bytes instanceof ArrayBuffer) {\r\n    return bytes;\r\n  }\r\n  if(bytes.buffer !== undefined &&\r\n    bytes.buffer.byteLength === bytes.length * bytes.BYTES_PER_ELEMENT) {\r\n    return bytes.buffer;\r\n  }\r\n  return bytesToArrayBuffer(bytes);\r\n} */\r\n\r\nexport function convertToUint8Array(bytes: Uint8Array | ArrayBuffer | number[] | string): Uint8Array {\r\n  if(bytes instanceof Uint8Array) {\r\n    return bytes;\r\n  } else if(typeof(bytes) === 'string') {\r\n    return new TextEncoder().encode(bytes);\r\n  }\r\n\r\n  return new Uint8Array(bytes);\r\n}\r\n\r\n/* export function bytesFromArrayBuffer(buffer: ArrayBuffer) {\r\n  const len = buffer.byteLength;\r\n  const byteView = new Uint8Array(buffer);\r\n  const bytes: number[] = [];\r\n\r\n  for(let i = 0; i < len; ++i) {\r\n    bytes[i] = byteView[i];\r\n  }\r\n\r\n  return bytes;\r\n}\r\n\r\nexport function bufferConcat(buffer1: any, buffer2: any) {\r\n  const l1 = buffer1.byteLength || buffer1.length;\r\n  const l2 = buffer2.byteLength || buffer2.length;\r\n  const tmp = new Uint8Array(l1 + l2);\r\n  tmp.set(buffer1 instanceof ArrayBuffer ? new Uint8Array(buffer1) : buffer1, 0);\r\n  tmp.set(buffer2 instanceof ArrayBuffer ? new Uint8Array(buffer2) : buffer2, l1);\r\n\r\n  return tmp.buffer;\r\n} */\r\n\r\nexport function bufferConcats(...args: (ArrayBuffer | Uint8Array | number[])[]) {\r\n  const length = args.reduce((acc, v) => acc + ((v as ArrayBuffer).byteLength || (v as Uint8Array).length), 0);\r\n\r\n  const tmp = new Uint8Array(length);\r\n  \r\n  let lastLength = 0;\r\n  args.forEach(b => {\r\n    tmp.set(b instanceof ArrayBuffer ? new Uint8Array(b) : b, lastLength);\r\n    lastLength += (b as ArrayBuffer).byteLength || (b as Uint8Array).length;\r\n  });\r\n\r\n  return tmp/* .buffer */;\r\n}\r\n\r\nexport function bytesFromWordss(input: Uint32Array) {\r\n  const o = new Uint8Array(input.byteLength);\r\n  for(let i = 0, length = input.length * 4; i < length; ++i) {\r\n    o[i] = ((input[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff);\r\n  }\r\n\r\n  return o;\r\n}\r\n\r\nexport function bytesToWordss(input: Parameters<typeof convertToUint8Array>[0]) {\r\n  const bytes = convertToUint8Array(input);\r\n\r\n  const words: number[] = [];\r\n  for(let i = 0, len = bytes.length; i < len; ++i) {\r\n    words[i >>> 2] |= bytes[i] << (24 - (i % 4) * 8);\r\n  }\r\n\r\n  return new Uint32Array(words);\r\n}\r\n\r\n// * https://stackoverflow.com/a/52827031\r\n/* export const isBigEndian = (() => {\r\n  const array = new Uint8Array(4);\r\n  const view = new Uint32Array(array.buffer);\r\n  return !((view[0] = 1) & array[0]);\r\n})(); */\r\n","/*\n * https://github.com/morethanwords/tweb\n * Copyright (C) 2019-2021 Eduard Kuzmenko\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\n */\n\nimport { bytesToHex, bytesFromHex, bufferConcats } from '../helpers/bytes';\n\nObject.defineProperty(Uint8Array.prototype, 'hex', {\n  get: function(): string {\n    return bytesToHex(this);\n  },\n  \n  set: function(str: string) {\n    this.set(bytesFromHex(str));\n  },\n  enumerable: true,\n  configurable: true\n});\n\nUint8Array.prototype.randomize = function() {\n  if(crypto && 'getRandomValues' in crypto) {\n    crypto.getRandomValues(this);\n  } else {\n    throw new Error('NO_SECURE_RANDOM');\n  }\n  \n  return this;\n};\n\nUint8Array.prototype.concat = function(...args: Array<Uint8Array | ArrayBuffer | number[]>) {\n  return bufferConcats(this, ...args);\n};\n\n/* Uint8Array.prototype.toString = function() {\n  return String.fromCharCode.apply(null, [...this]);\n}; */\n\nUint8Array.prototype.toJSON = function() {\n  return [...this];\n  //return {type: 'bytes', value: [...this]};\n};\n\nArray.prototype.findAndSplice = function<T>(verify: (value: T, index?: number, array?: Array<T>) => boolean) {\n  let index = this.findIndex(verify);\n  return index !== -1 ? this.splice(index, 1)[0] : undefined;\n};\n\nString.prototype.toHHMMSS = function(leadZero = false) {\n  const sec_num = parseInt(this + '', 10);\n  const hours = Math.floor(sec_num / 3600);\n  let minutes: any = Math.floor((sec_num - (hours * 3600)) / 60);\n  let seconds: any = sec_num - (hours * 3600) - (minutes * 60);\n  \n  if(hours) leadZero = true;\n  if(minutes < 10) minutes = leadZero ? \"0\" + minutes : minutes;\n  if(seconds < 10) seconds = \"0\" + seconds;\n  return (hours ? /* ('0' + hours).slice(-2) */hours + ':' : '') + minutes + ':' + seconds;\n};\n\n/* Promise.prototype.finally = Promise.prototype.finally || {\n  finally(fn: () => any) {\n    const onFinally = (callback: typeof fn) => Promise.resolve(fn()).then(callback);\n    return this.then(\n      result => onFinally(() => result),\n      reason => onFinally(() => Promise.reject(reason))\n    );\n  }\n}.finally; */\nPromise.prototype.finally = Promise.prototype.finally || function<T>(this: Promise<T>, fn: () => any) {\n  const onFinally = (callback: typeof fn) => Promise.resolve(fn()).then(callback);\n  return this.then(\n    result => onFinally(() => result),\n    reason => onFinally(() => Promise.reject(reason))\n  );\n};\n\nPromise.prototype.safeFinally = function<T>(this: Promise<T>, fn: () => any) {\n  return this.catch(() => {}).finally(fn);\n};\n\ndeclare global {\n  interface Uint8Array {\n    hex: string;\n    randomize: () => Uint8Array,\n    concat: (...args: Array<Uint8Array | ArrayBuffer | number[]>) => Uint8Array,\n    //toString: () => string,\n    toJSON: () => number[],\n    //toJSON: () => {type: 'bytes', value: number[]},\n  }\n  \n  interface Array<T> {\n    findAndSplice(verify: (value: T, index?: number, array?: Array<T>) => boolean): T;\n  }\n  \n  interface String {\n    toHHMMSS(leadZero?: boolean): string;\n  }\n\n  interface Promise<T> {\n    finally: (onfinally?: () => void) => Promise<T>;\n    safeFinally: (onfinally?: () => void) => Promise<T>;\n  }\n}\n"],"sourceRoot":""}